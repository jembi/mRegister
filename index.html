<!DOCTYPE html>
<html>

<head>
  <title>LHC-Forms FHIR R5 Example</title>
  <link href="https://lhcforms-static.nlm.nih.gov/lforms-versions/36.3.2/webcomponent/styles.css" rel="stylesheet" />
</head>

<body>
  <div id="myFormContainer"></div>

  <script src="https://lhcforms-static.nlm.nih.gov/lforms-versions/36.3.2/webcomponent/assets/lib/zone.min.js"></script>
  <script src="https://lhcforms-static.nlm.nih.gov/lforms-versions/36.3.2/webcomponent/lhc-forms.js"></script>
  <script src="https://lhcforms-static.nlm.nih.gov/lforms-versions/36.3.2/fhir/R5/lformsFHIR.min.js"></script>

  <script>
    const BASE_QUESTIONNAIRE_URL = "./questionnaires";

    // Function to inject expansion for a ValueSet if needed
    function injectExpansionFromCompose(valueSet) {
      if (!valueSet.expansion && valueSet.compose?.include?.length) {
        valueSet.expansion = { contains: [] };
        valueSet.compose.include.forEach(inc => {
          (inc.concept || []).forEach(concept => {
            valueSet.expansion.contains.push({
              system: inc.system,
              code: concept.code,
              display: concept.display
            });
          });
        });
      }
    }

    // Function to get the 'text' from the original Questionnaire items
    function getTextFromQuestionnaireItem(linkId, originalItems) {
      const item = originalItems.find(i => i.linkId === linkId);
      return item ? item.text : linkId; // If no match, fallback to the linkId
    }

    // Recursive function to collect all answers, including nested items
    function collectAnswers(userItems, originalItems, answeredItems = []) {
      userItems.forEach(userItem => {
        const match = originalItems.find(orig => orig.linkId === userItem.linkId);

        if (userItem.value !== undefined && userItem.value !== null && userItem.value !== '') {
          answeredItems.push({
            code: userItem.linkId,
            value: userItem.value,
            text: getTextFromQuestionnaireItem(userItem.linkId, originalItems) // Get the text for the question
          });
        }

        if (userItem.items && userItem.items.length > 0 && match?.items) {
          collectAnswers(userItem.items, match.items, answeredItems);
        }
      });
      return answeredItems;
    }

    let lfData;

    document.addEventListener('DOMContentLoaded', function () {
      // Fetch parent and child questionnaires in parallel
      Promise.all([
        fetch(`${BASE_QUESTIONNAIRE_URL}/questionnaire1-schema.json`).then(res => res.json()),
        fetch(`${BASE_QUESTIONNAIRE_URL}/questionnaire2-schema.json`).then(res => res.json())
      ])
        .then(([parentQ, childQ]) => {
          // Inject ValueSet expansions if needed
          if (parentQ.contained) {
            for (let res of parentQ.contained) {
              if (res.resourceType === 'ValueSet') {
                injectExpansionFromCompose(res);  // This now works since the function is defined
              }
            }
          }

          // Find and merge the child questionnaire items
          const placeholderItem = parentQ.item.find(it => it.linkId === 'HIV.D4ScreenForTb.History');
          if (placeholderItem && Array.isArray(childQ.item)) {
            placeholderItem.item = childQ.item;
          }

          // Set FHIR context and convert
          LForms.Util.setFHIRContext(parentQ);
          lfData = LForms.Util.convertFHIRQuestionnaireToLForms(parentQ, 'R5');
          LForms.Util.addFormToPage(lfData, 'myFormContainer');

          // Submit button
          const submitBtn = document.createElement('button');
          submitBtn.type = 'button';
          submitBtn.innerText = 'Submit Form';
          submitBtn.classList.add('btn', 'btn-primary');
          const formContainer = document.getElementById('myFormContainer');
          formContainer.appendChild(submitBtn);

          submitBtn.addEventListener('click', function () {
            try {
              const formElement = document.querySelector('#myFormContainer > div');

              sendDataToServer(formElement);

            } catch (error) {
              console.error('Error gathering form data:', error);
            }
          });
        })
        .catch(error => {
          console.error('Error loading questionnaires:', error);
        });
    });

    function sendDataToServer(theFormElement) {
      const userData = LForms.Util.getUserData(theFormElement, 'QuestionnaireResponse', 'R5');

      // Log userData to inspect the structure
      console.log('userData:', userData);

      // Access the actual itemsData array inside the object
      const itemsData = userData.itemsData;

      // Log itemsData to verify it's an array
      console.log('itemsData:', itemsData);

      if (Array.isArray(itemsData)) {
        // If itemsData is an array, proceed with transformation
        const questionnaireResponse = transformToFHIRQuestionnaireResponse(itemsData);

        // Send the QuestionnaireResponse to the FHIR server
        fetch('http://localhost:5001/fhir', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/fhir+json',
            'Authorization': 'Custom auth'
          },
          body: JSON.stringify(questionnaireResponse)
        })
          .then(async response => {
            const text = await response.text();
            if (!response.ok) throw new Error(`HTTP ${response.status} - ${text}`);
            return text;
          })
          .then(data => console.log('Submission successful:', data))
          .catch(error => console.error('Error submitting:', error));
      } else {
        console.error('Expected itemsData to be an array, but got:', typeof itemsData);
        // Handle the case where itemsData is not an array (if necessary)
      }
    }

    // Function to transform the user data into a valid FHIR QuestionnaireResponse format
    function processItem(item) {
      if (!item || !item.questionCode) {
        console.error('Invalid item:', item);
        return null;
      }

      // If it's a group, recurse into its items
      if (item.type === 'group' || item.items) {
        const groupItem = {
          linkId: item.questionCode,
          item: []
        };

        if (item.items && Array.isArray(item.items)) {
          for (const child of item.items) {
            const processedChild = processItem(child);
            if (processedChild) {
              groupItem.item.push(processedChild);
            }
          }
        }

        return groupItem;
      }

      // Otherwise, it's a regular question with a value
      const responseItem = {
        linkId: item.questionCode,
        answer: []
      };

      const val = item.value;

      if (val && typeof val === 'object' && val.code && val.system) {
        responseItem.answer.push({
          valueCoding: {
            code: val.code,
            system: val.system,
            display: val.text
          }
        });
      } else if (typeof val === 'string') {
        responseItem.answer.push({ valueString: val });
      } else if (typeof val === 'boolean') {
        responseItem.answer.push({ valueBoolean: val });
      } else if (typeof val === 'number') {
        responseItem.answer.push({ valueInteger: val });
      } else if (val instanceof Date) {
        responseItem.answer.push({ valueDate: val.toISOString().split('T')[0] });
      } else {
        console.warn('Unrecognized or missing value for item:', item);
        return null;
      }

      return responseItem;
    }


    function transformToFHIRQuestionnaireResponse(itemsData) {
      const questionnaireResponse = {
        resourceType: "QuestionnaireResponse",
        status: "completed",
        authored: new Date().toISOString(),
        item: []
      };

      const seenLinkIds = new Set();

      function processItem(item) {
        if (!item || !item.questionCode || seenLinkIds.has(item.questionCode)) {
          return null; // Skip if already processed
        }
        seenLinkIds.add(item.questionCode);

        if (item.items && Array.isArray(item.items)) {
          const groupItem = {
            linkId: item.questionCode,
            item: item.items
              .map(processItem)
              .filter(Boolean)
          };
          return groupItem;
        }

        const responseItem = {
          linkId: item.questionCode,
          answer: []
        };

        const val = item.value;

        if (val && typeof val === 'object' && val.code && val.system) {
          responseItem.answer.push({
            valueCoding: {
              code: val.code,
              system: val.system,
              display: val.text
            }
          });
        } else if (typeof val === 'string') {
          responseItem.answer.push({ valueString: val });
        } else if (typeof val === 'boolean') {
          responseItem.answer.push({ valueBoolean: val });
        } else if (typeof val === 'number') {
          responseItem.answer.push({ valueInteger: val });
        } else if (val instanceof Date) {
          responseItem.answer.push({ valueDate: val.toISOString().split('T')[0] });
        } else {
          return null;
        }

        return responseItem;
      }

      questionnaireResponse.item = itemsData
        .map(processItem)
        .filter(Boolean);

      return questionnaireResponse;
    }







  </script>
</body>

</html>